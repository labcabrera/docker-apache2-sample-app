= Ejempos de proxy inverso en contenedores docker

Este proyecto contiene varios ejemplos utilizando docker del uso de Apache2 como proxy inverso de
nuestras aplicaciones.

El primer ejemplo consistirá en exponer por el puerto 80 una aplicacion que escucha por HTTP
en el puerto 8080. En el segundo expondremos una aplicacion que internamente utiza HTTPS para
exponerla por el puerto 443. En el tercero utilizaremos el módulo de caché de contenidos.

== Ejemplo usando HTTP

Ejemplo sencillo de como configurar una imagen docker para exponer una aplicación ejecutándose en
el puerto 8080 a través de apache por el puerto 80

Para ello en primer lugar generamos el Dockerfile a partir de una imagen de debian

----
FROM debian:8.10
----

Instalamos apache2 junto con el módulo mod_proxy y ruby para hacer de servidor de aplicación en el
puerto 8080.
Despues simplemente activamos el módulo y generamos la configuración de apache en
`/etc/apache2/sites-enabled/000-default.conf`.

Finalmente en el script de arranque arrancamos el servicio de apache2 e iniciamos nuestro servidor
de ejemplo a través del script `entrypoint.sh`:

----
ruby -run -e httpd /opt/sample-app -p 8080
----

=== Desplegando localmente la imagen

En primer lugar ejecutaremos el script `docker-create-image.sh` que generará la imagen:

----
docker run \
  --interactive \
  --tty \
  --name $IMAGE_NAME \
  --hostname $IMAGE_NAME \
  --publish 80:80 \
  $IMAGE_USER/$IMAGE_NAME:${IMAGE_VERSION}
----

Una vez generada la imagen la arrancaremos con el script `docker-create-container.sh`

----
docker run \
  --interactive \
  --tty \
  --name $IMAGE_NAME \
  --hostname $IMAGE_NAME \
  --publish 80:80 \
  $IMAGE_USER/$IMAGE_NAME:${IMAGE_VERSION}
----

Si todo ha ido bien podremos acceder a nuestra aplicación: http://localhost/

=== Configuración de apache

En este ejemplo el fichero de configuración de apache es:

----
<VirtualHost *:*>
    ProxyPreserveHost On
    ProxyPass / http://0.0.0.0:8080/
    ProxyPassReverse / http://0.0.0.0:8080/
    ServerName localhost
</VirtualHost>
----

=== Ejecutando la imagen a través de un proxy

En este caso hemos creado dos argumentos `IMAGE_PROXY` y `IMAGE_NO_PROXY` en nuestra imagen para
aquellos casos en los que no tengamos salida directa a internet de tal modo que podremos generar la
imagen pasando estos parámetros:

----
--build-arg IMAGE_PROXY=$PROXY \
--build-arg IMAGE_NO_PROXY=$NO_PROXY \
----

== Ejemplo usando HTTPS

En el segundo ejemplo expondremos un microservicio que escucha en el puerto 9009 usando su propia
configuración de SSL.

En este caso es una aplicación Spring Boot de ejemplo (https://github.com/labcabrera/http-network-diagnostic/).

Básicamente es igual que la anterior exceptuando que la imagen la hemos generado a partir de

----
FROM openjdk:8u151-jdk
----

para evitar instalar la JDK. Después tendremos que copiar el certificado y la clave privada para
la configuración de SSL de apache. También cambiaremos nuestro `entrypoint.sh` para tener:

----
java -jar /opt/sample-app/http-network-diagnostic-1.0.3.jar
----

=== Configuración de apache

En este ejemplo el fichero de configuración de apache es:

----
<VirtualHost *:443>
  ServerName localhost

  SSLEngine On
  SSLProxyEngine On
  SSLProxyCheckPeerCN Off
  SSLCertificateFile	/root/certificate.pem
  SSLCertificateKeyFile /root/key.pem

  ProxyRequests Off
  ProxyPreserveHost On
  ProxyPass / https://0.0.0.0:9009/
  ProxyPassReverse / https://0.0.0.0:9009/

  <Location />
    ProxyPassReverse /
    Options FollowSymLinks
    Require all granted
  </Location>

</VirtualHost>
----

Si accedemos a https://localhost veremos la página de Swagger de nuestra aplicación.

== Ejemplo utilizando disk cache

Este ejemplo es una extensión de la segunda imagen en la que utilizaremos la cache en disco para
servir el contenido estático (en la aplicación de ejemplo esto serán los recursos de swagger).

Para ello instalaremos el módulo _cache_disk_ y lo activaremos a través del comando:

----
a2enmod cache_disk
----

Después modificaremos nuestro fichero de configuración de apache para incluir la siguiente
configuración:

----
  # Cache
  CacheQuickHandler off
  CacheLock On
  CacheRoot /tmp/cache/mod_cache
  CacheLockPath /tmp/cache/mod_cache_lock
  CacheIgnoreCacheControl On
  CacheMaxFileSize 100000000
  CacheIgnoreNoLastMod On
  CacheMaxExpire 1209600
  CacheIgnoreQueryString Off

  Header unset Set-Cookie
  Header unset Etag
  Header unset Pragma
  RequestHeader unset Cookie
  Header merge Cache-Control public
  Header merge Cache-Control "max-age=bidon"
  Header edit Cache-Control "^(.*)max-age=(.*)max-age=bidon, (.*)$" $1max-age=$2$3
  Header edit Cache-Control "^(.*)max-age=(.*), max-age=bidon$" $1max-age=$2
  Header edit Cache-Control "max-age=bidon" "max-age=600"
  Header edit Cache-Control "max-age=0" "max-age=600"
  Header edit Cache-Control "no-cache, " ""
  Header edit Cache-Control "no-store, " ""
  Header edit Cache-Control "post-check=0, " ""
  Header edit Cache-Control "pre-check=0, " ""
  Header edit Cache-Control "must-revalidate, " ""
----

Y activaremos este módulo para nuestro proxy inverso con la aplicación de Ruby que ejecutamos
localmente:

----
<Location "/">
  ...
  CacheEnable disk
  CacheHeader on
</Location>
----

Al arrancar la imagen podremos comprobar el funcionamiento realizando peticiones a:

https://localhost/swagger-ui.html

Si entramos en el contenedor veremos que ha creado la siguiente estructura de directorios:

----
root@apache-sample-cache:/tmp/cache# tree .
.
├── mod_cache
│   ├── 0D
│   │   └── @R
│   │       ├── A48aZby4l4TdtVbwdA.header
│   │       └── A48aZby4l4TdtVbwdA.header.vary
│   │           └── 1k
│   │               └── cF
│   │                   ├── 9cMtUUJYyh4n5gv39Q.data
│   │                   └── 9cMtUUJYyh4n5gv39Q.header
│   ├── 7T
│   │   └── @A
│   │       ├── Ddpii7mknOHLaj4umw.header
│   │       └── Ddpii7mknOHLaj4umw.header.vary
│   │           └── 9N
│   │               └── TK
│   │                   ├── 0YcoBvhzQwYfN3SosA.data
│   │                   └── 0YcoBvhzQwYfN3SosA.header
│   ├── Bs
│   │   └── 0p
│   │       ├── _wNe0@Rarv4M3JXWUQ.header
│   │       └── _wNe0@Rarv4M3JXWUQ.header.vary
│   │           └── mh
...
----

Y como hemos establecido el log a nivel de debug comprobaremos que al servir las peticiones recurre
a la caché en lugar de realizar la llamada a nuestra aplicación:

----
[Thu May 03 10:57:09.268606 2018] [ssl:info] [pid 37:tid 139774954211072] [client 172.17.0.1:48190] AH01964: Connection to child 88 established (server localhost:443)
[Thu May 03 10:57:09.268907 2018] [ssl:debug] [pid 37:tid 139774954211072] ssl_engine_kernel.c(2115): [client 172.17.0.1:48190] AH02043: SSL virtual host for servername localhost found
[Thu May 03 10:57:09.268939 2018] [ssl:debug] [pid 37:tid 139774954211072] ssl_engine_kernel.c(2115): [client 172.17.0.1:48190] AH02043: SSL virtual host for servername localhost found
[Thu May 03 10:57:09.268947 2018] [core:debug] [pid 37:tid 139774954211072] protocol.c(2219): [client 172.17.0.1:48190] AH03155: select protocol from , choices=h2,http/1.1 for server localhost
[Thu May 03 10:57:09.269898 2018] [ssl:debug] [pid 37:tid 139774954211072] ssl_engine_kernel.c(2042): [client 172.17.0.1:48190] AH02041: Protocol: TLSv1.2, Cipher: ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits)
[Thu May 03 10:57:09.270415 2018] [ssl:debug] [pid 37:tid 139774954211072] ssl_engine_kernel.c(366): [client 172.17.0.1:48190] AH02034: Initial (No.1) HTTPS request received for child 88 (server localhost:443)
[Thu May 03 10:57:09.270484 2018] [authz_core:debug] [pid 37:tid 139774954211072] mod_authz_core.c(809): [client 172.17.0.1:48190] AH01626: authorization result of Require all granted: granted
[Thu May 03 10:57:09.270493 2018] [authz_core:debug] [pid 37:tid 139774954211072] mod_authz_core.c(809): [client 172.17.0.1:48190] AH01626: authorization result of <RequireAny>: granted
[Thu May 03 10:57:09.270536 2018] [cache:debug] [pid 37:tid 139774954211072] cache_storage.c(666): [client 172.17.0.1:48190] AH00698: cache: Key for entity /webjars/springfox-swagger-ui/swagger-ui-bundle.js?v=2.8.0-SNAPSHOT is https://localhost:443/webjars/springfox-swagger-ui/swagger-ui-bundle.js?v=2.8.0-SNAPSHOT
[Thu May 03 10:57:09.270599 2018] [cache_disk:debug] [pid 37:tid 139774954211072] mod_cache_disk.c(573): [client 172.17.0.1:48190] AH00709: Recalled cached URL info header https://localhost:443/webjars/springfox-swagger-ui/swagger-ui-bundle.js?v=2.8.0-SNAPSHOT
[Thu May 03 10:57:09.270612 2018] [cache_disk:debug] [pid 37:tid 139774954211072] mod_cache_disk.c(897): [client 172.17.0.1:48190] AH00720: Recalled headers for URL https://localhost:443/webjars/springfox-swagger-ui/swagger-ui-bundle.js?v=2.8.0-SNAPSHOT
[Thu May 03 10:57:14.180226 2018] [ssl:debug] [pid 37:tid 139774945818368] ssl_engine_io.c(1044): [remote 172.17.0.1:48190] AH02001: Connection closed to child 88 with standard shutdown (server localhost:443)

----

Si modificamos el fichero _/opt/sample-app/hello.html_ veremos que el apache sigue sirviendo el
mismo contenido con la configuración que hemos establecido.

Para tener controlada nuestra cache podemos utilizar el binario _htcacheclean_ que se encarga
periodicamente de controlar el tamaño de nuestra caché:

----
$ htcacheclean -t -n -d1 -p /tmp/cache/mod_cache -l4000M
$ ps -fea | grep cache
root       156     0  0 09:43 ?        00:00:00 htcacheclean -t -n -d1 -p /tmp/cache/mod_cache -l4000M
root       158   106  0 09:44 pts/1    00:00:00 grep cache
----


Para saber más consultar la documentación oficial:

* https://httpd.apache.org/docs/2.4/mod/mod_cache.html#cachelock
* http://httpd.apache.org/docs/2.2/mod/mod_disk_cache.html
